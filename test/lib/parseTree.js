/**
 * Utility methods to extract information from the intermediate representation (tree) generated by the parser
 */
var _ = require("underscore");

exports.create = function (tree) {
	var isTree = tree && tree.type === "template" && tree.name && tree.content;

	// Prototype of any element that is contained in the tree
	var contentElement = {
		/**
		 * Whether the element is a text node
		 * @param  {String}  content [Optinal] Text node content (trimmed for comparison)
		 * @throws
		 */
		isText : function (content) {
			if (this.element.type !== "text") {
				// Surely enough this is not a text node
				throw new Error("Element " + this.path + " is not of type text but '" + this.element.type + "'.");
			}

			if (content && this.element.content.trim() !== content.trim()) {
				// Content is different from what expected
				throw new Error("Text Element " + this.path + " doesn't match '" + content.trim() + "'\nValue: '" + this.element.content + "'.");
			}
		},

		/**
		 * Whether the element is a certain instruction
		 * @param  {String}  name Instruction name
		 * @return {Boolean}
		 */
		isInstruction : function (name) {
			return this.element.type === "instruction" && this.element.name === name;
		},

		/**
		 * Whether the element is an HTML element.
		 * @param  {String}  tagName Tag name
		 * @throws
		 */
		isElement : function (tagName) {
			if (this.element.type !== "element") {
				throw new Error("Element " + this.path + " is not an HTML element. Type: " + this.element.type);
			}
			if (this.element.name !== tagName) {
				throw new Error("Element " + this.path + " is not a " + tagName + " but a " + this.element.name);
			}
		},

		/**
		 * Whether the current element is a variable or not. The path should be an array, while isBindModified is
		 * optional and defaults to false
		 * @param  {Array}   path            Path variable 'a.b.c' -> ['a', 'b', 'c']
		 * @param  {Boolean} isBindModified  Whether this variable has a binding modifier or not
		 * @throws
		 */
		isVariable : function (path, isBindModified) {
			isBindModified = isBindModified === true;
			if (this.element.type !== "value") {
				throw new Error("Element " + this.path + " is not a variable. Type: " + this.element.type);
			}
			var elementPath = this.element.args.join(".");
			var expectedPath = path.join(".");
			if (elementPath !== expectedPath) {
				throw new Error("Variable path in " + this.path + " is different from '" + expectedPath + "', got '" + elementPath + "'");
			}
			if (this.element.bind !== isBindModified) {
				throw new Error("Variable binding in " + this.path + " is different from '" + isBindModified + "', got '" + this.element.bind + "'");
			}
		},

		/**
		 * Return a property of the current element
		 * @param  {String} what Property name
		 * @return {Object}
		 */
		get : function (what) {
			return this.element[what];
		},

		/**
		 * Return an helper around the n-th element contained in this element.
		 * @param  {Number} position Index
		 * @return {Object}
		 */
		n : function (position) {
			return Object.create(contentElement, {
				element : {
					writable : false,
					configurable : false,
					value : this.element.content[position]
				},
				path : {
					writable : false,
					configurable : false,
					value : this.path + ".content[" + position + "]"
				}
			});
		}
	};

	return Object.create({
		/**
		 * Is this a valid parsed tree
		 * @return {Boolean}
		 */
		isTree : function () {
			return isTree;
		},

		/**
		 * Whether the tree has as many content nodes as specified.
		 * @param  {Number}  howMany How many content nodes we expect, if null anything bigger than 0
		 * @return {Boolean}
		 */
		hasContent : function (howMany) {
			if (!isTree) {
				throw new Error("Invalid parse tree");
			}

			if (_.isNumber(howMany)) {
				return tree.content.length === howMany;
			} else {
				return tree.content.length > 0;
			}
		},

		/**
		 * Return an helper around the n-th element of the template, 0 based index.
		 * @param  {Number} position Index
		 * @return {Object}
		 */
		n : function (position) {
			return Object.create(contentElement, {
				element : {
					writable : false,
					configurable : false,
					value : this.tree.content[position]
				},
				path : {
					writable : false,
					configurable : false,
					value : "tree.content[" + position + "]"
				}
			});
		},

		/**
		 * Log in the console the tree structure.
		 * @param  {Object} tree
		 */
		log : function (tree) {
			console.log(require("util").inspect(this.tree, false, null, true));
		}
	}, {
		tree : {
			writable : false,
			configurable : false,
			value : tree
		}
	});
};