exports.readFileSync=function(){return "/*\r\n * Partial grammar for hashspace that separates all statement or html element blocks\r\n * and return it as an Array\r\n * \r\n * The last part of this file corresponds to fragments of the JavaScript grammar \r\n * written by David Majda (minor modifications have been added to cope \r\n * with hashspace constraints)\r\n * @see https://github.com/dmajda/pegjs\r\n */\r\n\r\nTemplateFile\r\n  = blocks:(TemplateBlock / TextBlock)*  /*(RequireBlock / TemplateBlock / TextBlock)* */\r\n  {return blocks;}\r\n\r\nTextBlock\r\n  = lines:(!(\"#\" _ \"template\") !(\"#\" _ [a-zA-Z0-9]+ _ \"template\") !(\"#\" _ \"require\") chars:[^\\n\\r]* eol:EOL {return chars.join(\"\")+eol})+ \r\n  {return {type:\"plaintext\", value:lines.join('')}}\r\n\r\nRequireBlock \"require block\" // TODO: finalize!\r\n  = _ \"# \" _ \"require\" _ (EOL / EOF) \r\n  {return {type:\"require\"}}\r\n\r\nTemplateBlock \"template block\"\r\n  = start:TemplateStart content:TemplateContent? end:TemplateEnd? \r\n  { start.content=content;\r\n    if (end) {start.closed=true;start.endLine=end.line;};\r\n    return start;\r\n  }\r\n\r\nTemplateStart \"template statement\"\r\n  = _ \"# \" _ m:((\"template\") / (c:[a-zA-Z0-9]+ _ \"template\") {return c.join('')})\r\n    S+ name:Identifier args:(TemplateController / ArgumentsDefinition / invarg:InvalidTplArgs)? _  EOL \r\n  {\r\n    var mod=\"\"; // modifier (e.g. \"export\")\r\n    if (m!==\"template\") {\r\n      mod=m;\r\n    }\r\n    if (args && args.invalidTplArg) {\r\n      if (mod) {\r\n        mod+=\" \";\r\n      }\r\n      return {type:\"invalidtemplate\", line:line, column:column, code: \"# \"+mod+\"template \"+name+\" \"+args.invalidTplArg}\r\n    } else {\r\n      if (args && args.ctl && args.constructor!==Array) {\r\n        // this template uses a controller\r\n        return {type:\"template\", name:name, mod:mod, controller:args.ctl, controllerRef: args.ctlref, line:line, column:column}\r\n      }\r\n      return {type:\"template\", name:name, mod:mod, args:(args==='')? []:args, line:line, column:column}\r\n    }\r\n  }\r\n\r\nTemplateController \"controller\"\r\n  = S+ \"using\" S+ ref:Identifier _ \":\" _ ctl:JSObjectRef\r\n  {return {ctl:ctl, ctlref:ref}}\r\n\r\nArgumentsDefinition \"arguments\"\r\n  = _ \"(\" _ first:Identifier? others:((_ \",\" _ arg:Identifier) {return arg})* _ \")\" \r\n  {var args = first ? [first] : []; if (others && others.length) args=args.concat(others);return args;}\r\n\r\nInvalidTplArgs\r\n  = _ chars:[^\\n\\r]+ &EOL\r\n  {return {invalidTplArg:chars.join('')}}\r\n\r\nTemplateEnd \"template end statement\"\r\n  = _ \"# \" _ \"/template\" _ (EOL / EOF) \r\n  {return {type:\"/template\",line:line,column:column}} \r\n\r\nTemplateContent \"template content\" // TODO: CSSClassExpression\r\n  = _ blocks:(  TplTextBlock \r\n                / CommentBlock / HTMLCommentBlock\r\n                / IfBlock / ElseIfBlock / ElseBlock / EndIfBlock \r\n                / ForeachBlock / EndForeachBlock\r\n                / HTMLElement / EndHTMLElement\r\n                / HspComponent / EndHspComponent\r\n                / ExpressionBlock\r\n                / InvalidHTMLElement\r\n                / InvalidBlock)* \r\n  {return blocks}\r\n\r\nTplTextBlock \"text\"\r\n  = chars:(TplTextChar)+ \r\n  {return {type:\"text\", value:chars.join(''), line:line, column:column}}\r\n\r\nTplTextChar \"text character\"\r\n  = \"\\\\{\" {return \"\\u007B\"}       // { = \\u007B\r\n  / \"\\\\}\" {return \"\\u007D\"}       // } = \\u007D\r\n  / \"\\\\n\" {return \"\\n\"}\r\n  / EOL &TemplateEnd {return \"\"}  // ignore last EOL\r\n  / EOL _ {return \" \"}\r\n  / \"#\" !(_ \"\\/template\") {return \"#\"}\r\n  / \"\\/\" !\"/\" {return \"/\"}\r\n  / \"\\\\/\" {return \"/\"}\r\n  / \"\\\\//\" {return \"//\"}\r\n  / \"\\\\<\" {return \"<\"}\r\n  / [^{#/<]\r\n\r\nInvalidBlock\r\n  = \"{\" chars:[^{}#]* \"}\"\r\n  {return {type:\"invalidblock\", code:chars.join(''), line:line, column:column}}\r\n\r\nIfBlock \"if statement\"\r\n  = \"{\" _ \"if \" _ expr:HExpression _ \"}\" EOS?\r\n  {return {type:\"if\", condition:expr, line:line, column:column}}\r\n\r\nElseIfBlock \"elseif statement\" \r\n  = \"{\" _ \"else \" _ \"if\" _ expr:HExpression _ \"}\" EOS?\r\n  {return {type:\"elseif\", condition:expr, line:line, column:column}}\r\n\r\nElseBlock\r\n  = \"{\" _ \"else\" _ \"}\" EOS?\r\n  {return {type:\"else\", line:line, column:column}}\r\n\r\nEndIfBlock\r\n  = \"{\" _ \"/if\" _ \"}\" EOS?\r\n  {return {type:\"endif\", line:line, column:column}}\r\n\r\nCommentBlock\r\n  = _ \"\\/\\/\" chars:[^\\r\\n]* &EOL\r\n  {return {type:\"comment\", value:chars.join('')}}\r\n\r\nHTMLCommentBlock\r\n  = \"<!--\" chars:HTMLCommentChar* \"-->\"\r\n  {return {type:\"comment\", value:chars.join('')}}\r\n\r\nHTMLCommentChar\r\n  = !\"-\" \"-\" !\">\" {return \"-\"}\r\n    / \"-\" !\"->\" {return \"-\"}\r\n    / !\"--\" \">\" {return \">\"}\r\n    / [^>\\-]\r\n\r\nForeachBlock\r\n  = \"{\" _ \"foreach \" _ args:( ForeachArgs / (\"(\" _ a:ForeachArgs _ \")\") {return a}) _ \"}\" EOS?\r\n  {return {type:\"foreach\", item:args.item, key:args.key, colref:args.colref, line:line, column:column}}\r\n\r\nForeachArgs\r\n  = ForeachArgs1 / ForeachArgs2\r\n\r\nForeachArgs1\r\n  = item:Identifier \" \" _ \"in \" _ col:JSObjectRef \r\n  {return {item:item, key:item+\"_key\", colref:col}}\r\n\r\nForeachArgs2\r\n  = key:Identifier _ \",\" _ item:Identifier \" \" _ \"in \" _ col:JSObjectRef \r\n  {return {item:item, key:key, colref:col}}\r\n\r\nEndForeachBlock\r\n  = \"{\" _ \"/foreach\" _ \"}\"\r\n  {return {type:\"endforeach\", line:line, column:column}}\r\n\r\nHTMLElement\r\n  = \"<\" name:HTMLName  atts:HTMLElementAttributes? S? end:\"/\"? \">\" EOS?\r\n  {return {type:\"element\", name:name, closed:(end!==\"\"), attributes:atts, line:line, column:column}}\r\n\r\nHTMLElementAttributes\r\n  = atts:((S att:(HTMLAttribute)) {return att})*\r\n\r\nEndHTMLElement // TODO support comments inside Element\r\n  = \"</\" name:HTMLName S? \">\" EOS?\r\n  {return {type:\"endelement\", name:name, line:line, column:column}}\r\n\r\nHspComponent\r\n  = \"<#\" ref:JSObjectRef  atts:HTMLElementAttributes? S? end:\"/\"? \">\" EOS?\r\n  {return {type:\"component\", ref:ref, closed:(end!==\"\"), attributes:atts, line:line, column:column}}\r\n\r\nEndHspComponent\r\n  = \"</#\" ref:JSObjectRef S? \">\" EOS?\r\n  {return {type:\"endcomponent\", ref:ref, line:line, column:column}}\r\n\r\nInvalidHTMLElement\r\n  = \"<\" code:[^\\r\\n]* EOL\r\n  {return {type:\"invalidelement\", code:'<'+code.join(''), line:line, column:column}}\r\n\r\nHTMLName\r\n  = first:[a-z] next:([a-z] / [0-9] / \"-\")* \r\n  {return first + next.join(\"\");}\r\n\r\nHTMLAttName\r\n  = first:[a-zA-Z#] next:([a-zA-Z] / [0-9] / \"-\")* \r\n  // uppercase chars are considered as error in the parse post-processor\r\n  {return first + next.join(\"\");}\r\n\r\nHTMLAttribute\r\n  = name:HTMLAttName v:(_ \"=\" _ \"\\\"\" value:HTMLAttributeValue \"\\\"\" {return value;})?\r\n  {\r\n    return {type:\"attribute\", name:name, value:v, line:line, column:column}\r\n  }\r\n\r\nHTMLAttributeValue\r\n  = (HTMLAttributeText / ExpressionBlock)*\r\n\r\nHTMLAttributeText\r\n  = chars:HTMLAttributeChar+\r\n  {return {type:\"text\", value:chars.join('')}}\r\n\r\nHTMLAttributeChar // TODO look at W3C specs\r\n  =   \"\\\\{\" {return \"\\u007B\"}  // { = \\u007B\r\n    / \"\\\\\\\"\" {return \"\\\"\"}\r\n    / [^{\\\"\\n\\r]\r\n\r\nExpressionBlock\r\n  = \"{\" ubflag:\":\"? e:HExpression* \"}\" // keep a list of expression to match expressions starting with a valid part\r\n  {\r\n    var r={};\r\n    if (e.length==1) {\r\n      r=e[0];\r\n      if (r.type!==\"invalidexpression\") {\r\n        r.expType=r.type; \r\n        r.type=\"expression\";\r\n      }\r\n      r.bound=(ubflag.length==0);\r\n      if (!r.category) {\r\n        r.category=\"jsexpression\";\r\n      }\r\n    } else {\r\n      var code=[], itm, valid=true, t;\r\n      for (var i=0, sz=e.length;sz>i;i++) {\r\n        t=e[i].type;\r\n        if (t===\"invalidexpression\") {\r\n          valid=false;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (valid) {\r\n        r.type=\"expression\";\r\n        r.category=\"jsexpression\";\r\n        r.expType=\"CssClassExpression\"\r\n        r.list=e;\r\n      } else {\r\n        // invalid expression\r\n        for (var i=0, sz=e.length;sz>i;i++) {\r\n          itm=e[i];\r\n          if (itm.value) {\r\n            code.push(itm.value);\r\n          } else if (itm.code) {\r\n            code.push(itm.code);\r\n          } else {\r\n            code.push(\"(...)\"); // TODO\r\n          }\r\n        }\r\n        r.type=\"expression\"; r.category=\"invalidexpression\"; r.code=code.join('');\r\n      }\r\n    }\r\n    r.line=line; \r\n    r.column=column;\r\n    return r;\r\n  }\r\n\r\nHExpression\r\n  =   HExpressionCssClassElt \r\n    / HExpressionContent \r\n    / \",\" __ cce:HExpressionCssClassElt {return cce}\r\n    / \",\" __ exp:HExpressionContent {return exp}\r\n    / InvalidExpressionValue\r\n\r\nHExpressionContent\r\n  =  ce:ConditionalExpressionNoIn\r\n  {if (!ce.category) ce.category=\"jsexpression\"; ce.expType=ce.type;ce.line=line;ce.column=column;return ce;}\r\n\r\nHExpressionCssClassElt\r\n  = head:LogicalORExpression __ \":\" __ tail:LogicalORExpression \r\n  {return {type:\"CssClassElement\", left:head, right:tail};}\r\n\r\nInvalidExpressionValue\r\n  = chars:[^}]+\r\n  {return {type:\"invalidexpression\", code:chars.join(''), line:line, column:column}}\r\n\r\n// White spaces\r\n    // mandatory padding including line breaks\r\nS \"white space\" \r\n  = empty:(WhiteSpace / \"\\u000D\" / \"\\u000A\")+\r\n\r\n_   // optional padding excluding line breaks\r\n  = WhiteSpace*\r\n\r\nWhiteSpace \"white space\"\r\n  = [\\t\\v\\f \\u00A0\\uFEFF]\r\n\r\nEOL \"end of line\"\r\n  = \"\\n\"\r\n  / \"\\r\\n\"\r\n  / \"\\r\"\r\n  / \"\\u2028\" // line separator\r\n  / \"\\u2029\" // paragraph separator\r\n\r\nEOS \"end of statement\" //\r\n  = empty:(_ EOL _)\r\n\r\nEOF \"end of file\"\r\n  = !.\r\n\r\n__ // changed\r\n  = (WhiteSpace / EOL / Comment)*\r\n\r\nComment \"comment\"\r\n  = MultiLineComment\r\n  / SingleLineComment\r\n\r\nMultiLineComment\r\n  = \"/*\" (!\"*/\" .)* \"*/\"\r\n\r\nSingleLineComment\r\n  = \"//\" (!EOL .)*\r\n\r\n// ################################################################################\r\n\r\nJSObjectRef \"JS object reference\"\r\n  = start:Identifier tail:(( \".\" pp:Identifier) {return pp}/ ( \"[\" idx:[0-9]+ \"]\") {return parseInt(idx.join(''),10)})*\r\n  {var r=[start]; if (tail && tail.length) r=r.concat(tail);return {category:\"objectref\", path:r, code:r.join('.')}}\r\n\r\nJSLiteral\r\n  = NullLiteral       { return {type:\"expression\", category: \"null\", code:\"null\"};}\r\n  / v:BooleanLiteral  { return {type:\"expression\", category: \"boolean\", value:v.value, code:\"\"+v.value};}\r\n  / v:NumericLiteral  { return {type:\"expression\", category: \"number\", value: v, code:\"\"+v};}\r\n  / v:StringLiteral   { return {type:\"expression\", category: \"string\",  value: v, code:\"\"+v};}\r\n\r\n// ################################################################################\r\n/*!\r\n * The last part of this file is taken & modified from the JavaScript PEGjs grammar \r\n * by David Majda\r\n * https://github.com/dmajda/pegjs\r\n *\r\n * JavaScript parser based on the grammar described in ECMA-262, 5th ed.\r\n * (http://www.ecma-international.org/publications/standards/Ecma-262.htm)\r\n */\r\nSourceCharacter\r\n  = .\r\n\r\nIdentifier \"identifier\"\r\n  = !ReservedWord name:IdentifierName { return name; }\r\n\r\nIdentifierName \"identifier\"\r\n  = start:IdentifierStart parts:IdentifierPart* \r\n  {return start + parts.join(\"\");}\r\n\r\nIdentifierStart\r\n  = Letter // should be UnicodeLetter to be fully ECMAScript compliant - cf. PEGS JS Grammar\r\n  / \"$\"\r\n  / \"_\"\r\n\r\nIdentifierPart\r\n  = IdentifierStart / Digit\r\n\r\nLetter\r\n  = [a-zA-Z]\r\n\r\nDigit\r\n  = [0-9]\r\n\r\nReservedWord\r\n  = Keyword / FutureReservedWord / NullLiteral / BooleanLiteral\r\n\r\nKeyword\r\n  = (\r\n        \"break\"\r\n      / \"case\"\r\n      / \"catch\"\r\n      / \"continue\"\r\n      / \"debugger\"\r\n      / \"default\"\r\n      / \"delete\"\r\n      / \"do\"\r\n      / \"else\"\r\n      / \"finally\"\r\n      / \"for\"\r\n      / \"function\"\r\n      / \"if\"\r\n      / \"instanceof\"\r\n      / \"in\"\r\n      / \"new\"\r\n      / \"return\"\r\n      / \"switch\"\r\n      / \"this\"\r\n      / \"throw\"\r\n      / \"try\"\r\n      / \"typeof\"\r\n      / \"var\"\r\n      / \"void\"\r\n      / \"while\"\r\n      / \"with\"\r\n    )\r\n    !IdentifierPart\r\n\r\nFutureReservedWord\r\n  = (\r\n        \"class\"\r\n      / \"const\"\r\n      / \"enum\"\r\n      / \"export\"\r\n      / \"extends\"\r\n      / \"import\"\r\n      / \"super\"\r\n    )\r\n    !IdentifierPart\r\n\r\nNullLiteral\r\n  = \"null\" \r\n  {return { type: \"nullliteral\", value: null }; }\r\n\r\nBooleanLiteral\r\n  = \"true\"  { return { type: \"booleanliteral\", value: true  }; }\r\n  / \"false\" { return { type: \"booleanliteral\", value: false }; }\r\n\r\nNumericLiteral \"number\"\r\n  = literal:(HexIntegerLiteral / DecimalLiteral) !IdentifierStart \r\n  {return literal;}\r\n\r\nHexIntegerLiteral\r\n  = \"0\" [xX] digits:HexDigit+ \r\n  {return parseInt(\"0x\" + digits.join(\"\"));}\r\n\r\nHexDigit\r\n  = [0-9a-fA-F]\r\n\r\nDecimalLiteral\r\n  = before:DecimalIntegerLiteral \".\" after:DecimalDigits? exponent:ExponentPart? \r\n    {return parseFloat(before + \".\" + after + exponent);}\r\n  / \".\" after:DecimalDigits exponent:ExponentPart? \r\n    {return parseFloat(\".\" + after + exponent);}\r\n  / before:DecimalIntegerLiteral exponent:ExponentPart? \r\n    {return parseFloat(before + exponent);}\r\n\r\nDecimalIntegerLiteral\r\n  = \"0\" / digit:NonZeroDigit digits:DecimalDigits? \r\n  {return digit + digits;}\r\n\r\nDecimalDigits\r\n  = digits:DecimalDigit+ \r\n  {return digits.join(\"\");}\r\n\r\nDecimalDigit\r\n  = [0-9]\r\n\r\nNonZeroDigit\r\n  = [1-9]\r\n\r\nExponentPart\r\n  = indicator:ExponentIndicator integer:SignedInteger \r\n  {return indicator + integer;}\r\n\r\nExponentIndicator\r\n  = [eE]\r\n\r\nSignedInteger\r\n  = sign:[-+]? digits:DecimalDigits \r\n  {return sign + digits;}\r\n\r\nStringLiteral \"string\"\r\n  = parts:('\"' DoubleStringCharacters? '\"' / \"'\" SingleStringCharacters? \"'\") \r\n  {return parts[1];}\r\n\r\nDoubleStringCharacters\r\n  = chars:DoubleStringCharacter+ { return chars.join(\"\"); }\r\n\r\nSingleStringCharacters\r\n  = chars:SingleStringCharacter+ { return chars.join(\"\"); }\r\n\r\nDoubleStringCharacter\r\n  = !('\"' / \"\\\\\" / EOL) char_:SourceCharacter { return char_;     }\r\n  / \"\\\\\" sequence:EscapeSequence              { return sequence;  }\r\n\r\nSingleStringCharacter\r\n  = !(\"'\" / \"\\\\\" / EOL) char_:SourceCharacter { return char_;     }\r\n  / \"\\\\\" sequence:EscapeSequence              { return sequence;  }\r\n\r\nEscapeSequence\r\n  = CharacterEscapeSequence\r\n  / \"0\" !DecimalDigit { return \"\\0\"; }\r\n  / HexEscapeSequence\r\n  / UnicodeEscapeSequence\r\n\r\nCharacterEscapeSequence\r\n  = SingleEscapeCharacter\r\n  / NonEscapeCharacter\r\n\r\nSingleEscapeCharacter\r\n  = char_:['\"\\\\bfnrtv] {\r\n      return char_\r\n        .replace(\"b\", \"\\b\")\r\n        .replace(\"f\", \"\\f\")\r\n        .replace(\"n\", \"\\n\")\r\n        .replace(\"r\", \"\\r\")\r\n        .replace(\"t\", \"\\t\")\r\n        .replace(\"v\", \"\\x0B\") // IE does not recognize \"\\v\".\r\n    }\r\n\r\nNonEscapeCharacter\r\n  = (!EscapeCharacter / EOL) char_:SourceCharacter { return char_; }\r\n\r\nEscapeCharacter\r\n  = SingleEscapeCharacter\r\n  / DecimalDigit\r\n  / \"x\"\r\n  / \"u\"\r\n\r\nHexEscapeSequence\r\n  = \"x\" h1:HexDigit h2:HexDigit \r\n  {return String.fromCharCode(parseInt(\"0x\" + h1 + h2));}\r\n\r\nUnicodeEscapeSequence\r\n  = \"u\" h1:HexDigit h2:HexDigit h3:HexDigit h4:HexDigit \r\n  {return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));}\r\n\r\n\r\n/* ===== A.3 Expressions ===== */\r\n\r\nPrimaryExpression // changed \r\n  = name:Identifier { return { type: \"Variable\", name: name, code:name }; }\r\n  / JSLiteral\r\n  / ArrayLiteral\r\n  / ObjectLiteral\r\n  / \"(\" __ expression:Expression __ \")\" { return expression; }\r\n\r\nArrayLiteral\r\n  = \"[\" __ elements:ElementList? __ (Elision __)? \"]\" {\r\n      return {\r\n        type:     \"ArrayLiteral\",\r\n        elements: elements !== \"\" ? elements : []\r\n      };\r\n    }\r\n\r\nElementList\r\n  = (Elision __)?\r\n    head:AssignmentExpression\r\n    tail:(__ \",\" __ Elision? __ AssignmentExpression)* {\r\n      var result = [head];\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result.push(tail[i][5]);\r\n      }\r\n      return result;\r\n    }\r\n\r\nElision\r\n  = \",\" (__ \",\")*\r\n\r\nObjectLiteral\r\n  = \"{\" __ properties:(PropertyNameAndValueList __ (\",\" __)?)? \"}\" {\r\n      return {\r\n        type:       \"ObjectLiteral\",\r\n        properties: properties !== \"\" ? properties[0] : []\r\n      };\r\n    }\r\n\r\nPropertyNameAndValueList\r\n  = head:PropertyAssignment tail:(__ \",\" __ PropertyAssignment)* {\r\n      var result = [head];\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result.push(tail[i][3]);\r\n      }\r\n      return result;\r\n    }\r\n\r\nPropertyAssignment // changed\r\n  = name:PropertyName __ \":\" __ value:AssignmentExpression {\r\n      return {\r\n        type:  \"PropertyAssignment\",\r\n        name:  name,\r\n        value: value\r\n      };\r\n    }\r\n\r\nPropertyName\r\n  = IdentifierName\r\n  / StringLiteral\r\n  / NumericLiteral\r\n\r\nPropertySetParameterList\r\n  = Identifier\r\n\r\nMemberExpression // changed\r\n  = base:(\r\n        PrimaryExpression\r\n    )\r\n    accessors:(\r\n        __ \"[\" __ name:Expression __ \"]\" { return name; }\r\n      / __ \".\" __ name:IdentifierName    { return name; }\r\n    )* {\r\n      var result = base;\r\n      for (var i = 0; i < accessors.length; i++) {\r\n        result = {\r\n          type: \"PropertyAccess\",\r\n          base: result,\r\n          name: accessors[i]\r\n        };\r\n      }\r\n      result.code=base.code\r\n      if (accessors.length) {\r\n        var acc;\r\n        for (var i=0, sz=accessors.length;sz>i;i++) {\r\n          acc=accessors[i];\r\n          if (acc.code) {\r\n            accessors[i]=acc.code;\r\n          }\r\n        }\r\n        result.code+=\".\"+accessors.join(\".\");\r\n      }\r\n      return result;\r\n    }\r\n\r\nNewExpression // changed\r\n  = MemberExpression\r\n\r\nCallExpression\r\n  = base:(\r\n      name:MemberExpression __ arguments:Arguments {\r\n        return {\r\n          type:      \"FunctionCall\",\r\n          name:      name,\r\n          arguments: arguments\r\n        };\r\n      }\r\n    )\r\n    argumentsOrAccessors:(\r\n        __ arguments:Arguments {\r\n          return {\r\n            type:      \"FunctionCallArguments\",\r\n            arguments: arguments\r\n          };\r\n        }\r\n      / __ \"[\" __ name:Expression __ \"]\" {\r\n          return {\r\n            type: \"PropertyAccessProperty\",\r\n            name: name\r\n          };\r\n        }\r\n      / __ \".\" __ name:IdentifierName {\r\n          return {\r\n            type: \"PropertyAccessProperty\",\r\n            name: name\r\n          };\r\n        }\r\n    )* {\r\n      var result = base;\r\n      for (var i = 0; i < argumentsOrAccessors.length; i++) {\r\n        switch (argumentsOrAccessors[i].type) {\r\n          case \"FunctionCallArguments\":\r\n            result = {\r\n              type:      \"FunctionCall\",\r\n              name:      result,\r\n              arguments: argumentsOrAccessors[i].arguments\r\n            };\r\n            break;\r\n          case \"PropertyAccessProperty\":\r\n            result = {\r\n              type: \"PropertyAccess\",\r\n              base: result,\r\n              name: argumentsOrAccessors[i].name\r\n            };\r\n            break;\r\n          default:\r\n            throw new Error(\r\n              \"Invalid expression type: \" + argumentsOrAccessors[i].type\r\n            );\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\nArguments\r\n  = \"(\" __ arguments:ArgumentList? __ \")\" {\r\n    return arguments !== \"\" ? arguments : [];\r\n  }\r\n\r\nArgumentList\r\n  = head:AssignmentExpression tail:(__ \",\" __ AssignmentExpression)* {\r\n    var result = [head];\r\n    for (var i = 0; i < tail.length; i++) {\r\n      result.push(tail[i][3]);\r\n    }\r\n    return result;\r\n  }\r\n\r\nLeftHandSideExpression\r\n  = CallExpression\r\n  / NewExpression\r\n\r\nPostfixExpression\r\n  = expression:LeftHandSideExpression _ operator:PostfixOperator {\r\n      return {\r\n        type:       \"PostfixExpression\",\r\n        operator:   operator,\r\n        expression: expression\r\n      };\r\n    }\r\n  / LeftHandSideExpression\r\n\r\nPostfixOperator\r\n  = \"++\"\r\n  / \"--\"\r\n\r\nUnaryExpression\r\n  = PostfixExpression\r\n  / operator:UnaryOperator __ expression:UnaryExpression {\r\n      return {\r\n        type:       \"UnaryExpression\",\r\n        operator:   operator,\r\n        expression: expression\r\n      };\r\n    }\r\n\r\nUnaryOperator // changed\r\n  = \"void\"\r\n  / \"typeof\"\r\n  / \"++\"\r\n  / \"--\"\r\n  / \"+\"\r\n  / \"-\"\r\n  / \"~\"\r\n  /  \"!\"\r\n\r\nMultiplicativeExpression\r\n  = head:UnaryExpression\r\n    tail:(__ MultiplicativeOperator __ UnaryExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nMultiplicativeOperator\r\n  = operator:(\"*\" / \"/\" / \"%\") !\"=\" { return operator; }\r\n\r\nAdditiveExpression\r\n  = head:MultiplicativeExpression\r\n    tail:(__ AdditiveOperator __ MultiplicativeExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nAdditiveOperator\r\n  = \"+\" !(\"+\" / \"=\") { return \"+\"; }\r\n  / \"-\" !(\"-\" / \"=\") { return \"-\"; }\r\n\r\nShiftExpression\r\n  = head:AdditiveExpression\r\n    tail:(__ ShiftOperator __ AdditiveExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nShiftOperator\r\n  = \"<<\"\r\n  / \">>>\"\r\n  / \">>\"\r\n\r\nRelationalExpression\r\n  = head:ShiftExpression\r\n    tail:(__ RelationalOperator __ ShiftExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nRelationalOperator\r\n  = \"<=\"\r\n  / \">=\"\r\n  / \"<\"\r\n  / \">\"\r\n  / \"instanceof\"\r\n  / \"in\"\r\n\r\nRelationalExpressionNoIn\r\n  = head:ShiftExpression\r\n    tail:(__ RelationalOperatorNoIn __ ShiftExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nRelationalOperatorNoIn\r\n  = \"<=\"\r\n  / \">=\"\r\n  / \"<\"\r\n  / \">\"\r\n  / \"instanceof\"\r\n\r\nEqualityExpression\r\n  = head:RelationalExpression\r\n    tail:(__ EqualityOperator __ RelationalExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nEqualityExpressionNoIn\r\n  = head:RelationalExpressionNoIn\r\n    tail:(__ EqualityOperator __ RelationalExpressionNoIn)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nEqualityOperator\r\n  = \"===\"\r\n  / \"!==\"\r\n  / \"==\"\r\n  / \"!=\"\r\n\r\nBitwiseANDExpression\r\n  = head:EqualityExpression\r\n    tail:(__ BitwiseANDOperator __ EqualityExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nBitwiseANDExpressionNoIn\r\n  = head:EqualityExpressionNoIn\r\n    tail:(__ BitwiseANDOperator __ EqualityExpressionNoIn)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nBitwiseANDOperator\r\n  = \"&\" !(\"&\" / \"=\") { return \"&\"; }\r\n\r\nBitwiseXORExpression\r\n  = head:BitwiseANDExpression\r\n    tail:(__ BitwiseXOROperator __ BitwiseANDExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nBitwiseXORExpressionNoIn\r\n  = head:BitwiseANDExpressionNoIn\r\n    tail:(__ BitwiseXOROperator __ BitwiseANDExpressionNoIn)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nBitwiseXOROperator\r\n  = \"^\" !(\"^\" / \"=\") { return \"^\"; }\r\n\r\nBitwiseORExpression\r\n  = head:BitwiseXORExpression\r\n    tail:(__ BitwiseOROperator __ BitwiseXORExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nBitwiseORExpressionNoIn\r\n  = head:BitwiseXORExpressionNoIn\r\n    tail:(__ BitwiseOROperator __ BitwiseXORExpressionNoIn)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nBitwiseOROperator\r\n  = \"|\" !(\"|\" / \"=\") { return \"|\"; }\r\n\r\nLogicalANDExpression\r\n  = head:BitwiseORExpression\r\n    tail:(__ LogicalANDOperator __ BitwiseORExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nLogicalANDExpressionNoIn\r\n  = head:BitwiseORExpressionNoIn\r\n    tail:(__ LogicalANDOperator __ BitwiseORExpressionNoIn)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nLogicalANDOperator\r\n  = \"&&\" !\"=\" { return \"&&\"; }\r\n\r\nLogicalORExpression\r\n  = head:LogicalANDExpression\r\n    tail:(__ LogicalOROperator __ LogicalANDExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nLogicalORExpressionNoIn\r\n  = head:LogicalANDExpressionNoIn\r\n    tail:(__ LogicalOROperator __ LogicalANDExpressionNoIn)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nLogicalOROperator\r\n  = \"||\" !\"=\" { return \"||\"; }\r\n\r\nConditionalExpression\r\n  = condition:LogicalORExpression __\r\n    \"?\" __ trueExpression:AssignmentExpression __\r\n    \":\" __ falseExpression:AssignmentExpression {\r\n      return {\r\n        type:            \"ConditionalExpression\",\r\n        condition:       condition,\r\n        trueExpression:  trueExpression,\r\n        falseExpression: falseExpression\r\n      };\r\n    }\r\n  / LogicalORExpression\r\n\r\n// This is the one we use in hashspace\r\nConditionalExpressionNoIn\r\n  = condition:LogicalORExpressionNoIn __\r\n    \"?\" __ trueExpression:AssignmentExpressionNoIn __\r\n    \":\" __ falseExpression:AssignmentExpressionNoIn {\r\n      return {\r\n        type:            \"ConditionalExpression\",\r\n        condition:       condition,\r\n        trueExpression:  trueExpression,\r\n        falseExpression: falseExpression\r\n      };\r\n    }\r\n  / LogicalORExpressionNoIn\r\n\r\n// Not used in hashspace\r\nAssignmentExpression\r\n  = left:LeftHandSideExpression __\r\n    operator:AssignmentOperator __\r\n    right:AssignmentExpression {\r\n      return {\r\n        type:     \"AssignmentExpression\",\r\n        operator: operator,\r\n        left:     left,\r\n        right:    right\r\n      };\r\n    }\r\n  / ConditionalExpression\r\n\r\nAssignmentExpressionNoIn\r\n  = left:LeftHandSideExpression __\r\n    operator:AssignmentOperator __\r\n    right:AssignmentExpressionNoIn {\r\n      return {\r\n        type:     \"AssignmentExpression\",\r\n        operator: operator,\r\n        left:     left,\r\n        right:    right\r\n      };\r\n    }\r\n  / ConditionalExpressionNoIn\r\n\r\nAssignmentOperator\r\n  = \"=\" (!\"=\") { return \"=\"; }\r\n  / \"*=\"\r\n  / \"/=\"\r\n  / \"%=\"\r\n  / \"+=\"\r\n  / \"-=\"\r\n  / \"<<=\"\r\n  / \">>=\"\r\n  / \">>>=\"\r\n  / \"&=\"\r\n  / \"^=\"\r\n  / \"|=\"\r\n\r\nExpression\r\n  = head:AssignmentExpression\r\n    tail:(__ \",\" __ AssignmentExpression)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n\r\nExpressionNoIn\r\n  = head:AssignmentExpressionNoIn\r\n    tail:(__ \",\" __ AssignmentExpressionNoIn)* {\r\n      var result = head;\r\n      for (var i = 0; i < tail.length; i++) {\r\n        result = {\r\n          type:     \"BinaryExpression\",\r\n          operator: tail[i][1],\r\n          left:     result,\r\n          right:    tail[i][3]\r\n        };\r\n      }\r\n      return result;\r\n    }\r\n"}