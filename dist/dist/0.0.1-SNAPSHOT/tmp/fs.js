exports.readFileSync=function(){return "/*\n * Partial grammar for hashspace that separates all statement or html element blocks\n * and return it as an Array\n * \n * The last part of this file corresponds to fragments of the JavaScript grammar \n * written by David Majda (minor modifications have been added to cope \n * with hashspace constraints)\n * @see https://github.com/dmajda/pegjs\n */\n\nTemplateFile\n  = blocks:(TemplateBlock / TextBlock)*  /*(RequireBlock / TemplateBlock / TextBlock)* */\n  {return blocks;}\n\nTextBlock\n  = lines:(!(\"#\" _ \"template\") !(\"#\" _ [a-zA-Z0-9]+ _ \"template\") !(\"#\" _ \"require\") chars:[^\\n\\r]* eol:EOL {return chars.join(\"\")+eol})+ \n  {return {type:\"plaintext\", value:lines.join('')}}\n\nRequireBlock \"require block\" // TODO: finalize!\n  = _ \"# \" _ \"require\" _ (EOL / EOF) \n  {return {type:\"require\"}}\n\nTemplateBlock \"template block\"\n  = start:TemplateStart content:TemplateContent? end:TemplateEnd? \n  {\n    start.content=content;\n    if (end) {start.closed=true;start.endLine=end.line;};\n    return start;\n  }\n\nTemplateStart \"template statement\"\n  = _ \"# \" _ m:((\"template\") / (c:[a-zA-Z0-9]+ _ \"template\") {return c.join('')})\n    S+ name:Identifier args:(TemplateController / ArgumentsDefinition / invarg:InvalidTplArgs)? _  EOL \n  {\n    var mod=\"\"; // modifier (e.g. \"export\")\n    if (m!==\"template\") {\n      mod=m;\n    }\n    if (args && args.invalidTplArg) {\n      if (mod) {\n        mod+=\" \";\n      }\n      return {type:\"invalidtemplate\", line:line, column:column, code: \"# \"+mod+\"template \"+name+\" \"+args.invalidTplArg}\n    } else {\n      if (args && args.ctl && args.constructor!==Array) {\n        // this template uses a controller\n        return {type:\"template\", name:name, mod:mod, controller:args.ctl, controllerRef: args.ctlref, line:line, column:column}\n      }\n      return {type:\"template\", name:name, mod:mod, args:(args==='')? []:args, line:line, column:column}\n    }\n  }\n\nTemplateController \"controller\"\n  = S+ \"using\" S+ ref:Identifier _ \":\" _ ctl:JSObjectRef\n  {return {ctl:ctl, ctlref:ref}}\n\nArgumentsDefinition \"arguments\"\n  = _ \"(\" _ first:VarIdentifier? others:((_ \",\" _ arg:VarIdentifier) {return arg})* _ \")\" \n  {var args = first ? [first] : []; if (others && others.length) args=args.concat(others);return args;}\n\nInvalidTplArgs\n  = _ chars:[^\\n\\r]+ &EOL\n  {return {invalidTplArg:chars.join('')}}\n\nTemplateEnd \"template end statement\"\n  = _ \"# \" _ \"/template\" _ (EOL / EOF) \n  {return {type:\"/template\",line:line,column:column}} \n\nTemplateContent \"template content\" // TODO: CSSClassExpression\n  = _ blocks:(  TplTextBlock \n                / CommentBlock / HTMLCommentBlock\n                / IfBlock / ElseIfBlock / ElseBlock / EndIfBlock \n                / ForeachBlock / EndForeachBlock\n                / HTMLElement / EndHTMLElement\n                / HspComponent / EndHspComponent\n                / HspCptAttribute / EndHspCptAttribute\n                / LogBlock\n                / ExpressionBlock\n                / InvalidHTMLElement\n                / InvalidBlock)* \n  {return blocks}\n\nTplTextBlock \"text\"\n  = chars:(TplTextChar)+ \n  {return {type:\"text\", value:chars.join(''), line:line, column:column}}\n\nTplTextChar \"text character\"\n  = \"\\\\{\" {return \"\\u007B\"}       // { = \\u007B\n  / \"\\\\}\" {return \"\\u007D\"}       // } = \\u007D\n  / \"\\\\n\" {return \"\\n\"}\n  / EOL &TemplateEnd {return \"\"}  // ignore last EOL\n  / EOL _ {return \" \"}\n  / \"#\" !(_ \"\\/template\") {return \"#\"}\n  / \"\\/\" !\"/\" {return \"/\"}\n  / \"\\\\/\" {return \"/\"}\n  / \"\\\\//\" {return \"//\"}\n  / \"\\\\<\" {return \"<\"}\n  / [^{#/<]\n\nInvalidBlock\n  = \"{\" chars:[^{}#]* \"}\"\n  {return {type:\"invalidblock\", code:chars.join(''), line:line, column:column}}\n\nIfBlock \"if statement\"\n  = \"{\" _ \"if \" _ expr:HExpression _ \"}\" EOS?\n  {return {type:\"if\", condition:expr, line:line, column:column}}\n\nElseIfBlock \"elseif statement\" \n  = \"{\" _ \"else \" _ \"if\" _ expr:HExpression _ \"}\" EOS?\n  {return {type:\"elseif\", condition:expr, line:line, column:column}}\n\nElseBlock\n  = \"{\" _ \"else\" _ \"}\" EOS?\n  {return {type:\"else\", line:line, column:column}}\n\nEndIfBlock\n  = \"{\" _ \"/if\" _ \"}\" EOS?\n  {return {type:\"endif\", line:line, column:column}}\n\nCommentBlock\n  = _ \"\\/\\/\" chars:[^\\r\\n]* &EOL\n  {return {type:\"comment\", value:chars.join('')}}\n\nHTMLCommentBlock\n  = \"<!--\" chars:HTMLCommentChar* \"-->\"\n  {return {type:\"comment\", value:chars.join('')}}\n\nHTMLCommentChar\n  = !\"-\" \"-\" !\">\" {return \"-\"}\n    / \"-\" !\"->\" {return \"-\"}\n    / !\"--\" \">\" {return \">\"}\n    / [^>\\-]\n\nForeachBlock\n  = \"{\" _ \"foreach \" _ args:( ForeachArgs / (\"(\" _ a:ForeachArgs _ \")\") {return a}) _ \"}\" EOS?\n  {return {type:\"foreach\", item:args.item, key:args.key, colref:args.colref, line:line, column:column}}\n\nForeachArgs\n  = ForeachArgs1 / ForeachArgs2\n\nForeachArgs1\n  = item:VarIdentifier \" \" _ \"in \" _ col:JSObjectRef \n  {return {item:item, key:item+\"_key\", colref:col}}\n\nForeachArgs2\n  = key:VarIdentifier _ \",\" _ item:VarIdentifier \" \" _ \"in \" _ col:JSObjectRef \n  {return {item:item, key:key, colref:col}}\n\nEndForeachBlock\n  = \"{\" _ \"/foreach\" _ \"}\"\n  {return {type:\"endforeach\", line:line, column:column}}\n\nHTMLElement\n  = \"<\" name:HTMLName  atts:HTMLElementAttributes? S? end:\"/\"? \">\" EOS?\n  {return {type:\"element\", name:name, closed:(end!==\"\"), attributes:atts, line:line, column:column}}\n\nHTMLElementAttributes\n  = atts:((S att:(HTMLAttribute)) {return att})*\n\nEndHTMLElement // TODO support comments inside Element\n  = \"</\" name:HTMLName S? \">\" EOS?\n  {return {type:\"endelement\", name:name, line:line, column:column}}\n\nHspComponent\n  = \"<#\" ref:JSObjectRef  atts:HTMLElementAttributes? S? end:\"/\"? \">\" EOS?\n  {return {type:\"component\", ref:ref, closed:(end!==\"\"), attributes:atts, line:line, column:column}}\n\nEndHspComponent\n  = \"</#\" ref:JSObjectRef S? \">\" EOS?\n  {return {type:\"endcomponent\", ref:ref, line:line, column:column}}\n\nHspCptAttribute\n  = \"<@\" ref:VarIdentifier  atts:HTMLElementAttributes? S? end:\"/\"? \">\" EOS?\n  {return {type:\"cptattribute\", name:ref, closed:(end!==\"\"), attributes:atts, line:line, column:column}}\n\nEndHspCptAttribute\n  = \"</@\" ref:VarIdentifier S? \">\" EOS?\n  {return {type:\"endcptattribute\", name:ref, line:line, column:column}}\n\nInvalidHTMLElement\n  = \"<\" code:[^\\r\\n]* EOL\n  {return {type:\"invalidelement\", code:'<'+code.join(''), line:line, column:column}}\n\nHTMLName\n  = first:[a-z] next:([a-z] / [0-9] / \"-\")* \n  {return first + next.join(\"\");}\n\nHTMLAttName\n  = first:[a-zA-Z#] next:([a-zA-Z] / [0-9] / \"-\")* \n  // uppercase chars are considered as error in the parse post-processor\n  {return first + next.join(\"\");}\n\nHTMLAttribute\n  = name:HTMLAttName v:(_ \"=\" _ \"\\\"\" value:HTMLAttributeValue \"\\\"\" {return value;})?\n  {\n    return {type:\"attribute\", name:name, value:v, line:line, column:column}\n  }\n\nHTMLAttributeValue\n  = (HTMLAttributeText / ExpressionBlock)*\n\nHTMLAttributeText\n  = chars:HTMLAttributeChar+\n  {return {type:\"text\", value:chars.join('')}}\n\nHTMLAttributeChar // TODO look at W3C specs\n  =   \"\\\\{\" {return \"\\u007B\"}  // { = \\u007B\n    / \"\\\\\\\"\" {return \"\\\"\"}\n    / [^{\\\"\\n\\r]\n\nLogBlock\n  = \"{\" _ \"log \" _ first:HExpressionContent _ next:(\",\" _ HExpressionContent)* _\"}\" EOS?\n  {\n    var exprs=[first];\n    if (next) {\n      for (var i=0, sz=next.length;sz>i;i++) {\n        exprs.push(next[i][2]);\n      }\n    }\n    return {type:\"log\",exprs:exprs, line:line, column:column};\n  }\n\nExpressionBlock\n  = \"{\" ubflag:\":\"? e:HExpression* \"}\" // keep a list of expression to match expressions starting with a valid part\n  {\n    var r={};\n    if (e.length==1) {\n      r=e[0];\n      if (r.type!==\"invalidexpression\") {\n        r.expType=r.type; \n        r.type=\"expression\";\n      }\n      r.bound=(ubflag.length==0);\n      if (!r.category) {\n        r.category=\"jsexpression\";\n      }\n    } else {\n      var code=[], itm, valid=true, t;\n      for (var i=0, sz=e.length;sz>i;i++) {\n        t=e[i].type;\n        if (t===\"invalidexpression\") {\n          valid=false;\n          break;\n        }\n      }\n\n      if (valid) {\n        r.type=\"expression\";\n        r.category=\"jsexpression\";\n        r.expType=\"CssClassExpression\"\n        r.list=e;\n      } else {\n        // invalid expression\n        for (var i=0, sz=e.length;sz>i;i++) {\n          itm=e[i];\n          if (itm.value) {\n            code.push(itm.value);\n          } else if (itm.code) {\n            code.push(itm.code);\n          } else {\n            code.push(\"(...)\"); // TODO\n          }\n        }\n        r.type=\"expression\"; r.category=\"invalidexpression\"; r.code=code.join('');\n      }\n    }\n    r.line=line; \n    r.column=column;\n    return r;\n  }\n\nHExpression\n  =   HExpressionCssClassElt \n    / HExpressionContent \n    / \",\" __ cce:HExpressionCssClassElt {return cce}\n    / \",\" __ exp:HExpressionContent {return exp}\n    / InvalidExpressionValue\n\nHExpressionContent\n  =  ce:ConditionalExpressionNoIn\n  {if (!ce.category) ce.category=\"jsexpression\"; ce.expType=ce.type;ce.line=line;ce.column=column;return ce;}\n\nHExpressionCssClassElt\n  = head:LogicalORExpression __ \":\" __ tail:LogicalORExpression \n  {return {type:\"CssClassElement\", left:head, right:tail};}\n\nInvalidExpressionValue\n  = chars:[^}]+\n  {return {type:\"invalidexpression\", code:chars.join(''), line:line, column:column}}\n\n// White spaces\n    // mandatory padding including line breaks\nS \"white space\" \n  = empty:(WhiteSpace / \"\\u000D\" / \"\\u000A\")+\n\n_   // optional padding excluding line breaks\n  = WhiteSpace*\n\nWhiteSpace \"white space\"\n  = [\\t\\v\\f \\u00A0\\uFEFF]\n\nEOL \"end of line\"\n  = \"\\n\"\n  / \"\\r\\n\"\n  / \"\\r\"\n  / \"\\u2028\" // line separator\n  / \"\\u2029\" // paragraph separator\n\nEOS \"end of statement\" //\n  = empty:(_ EOL _)\n\nEOF \"end of file\"\n  = !.\n\n__ // changed\n  = (WhiteSpace / EOL / Comment)*\n\nComment \"comment\"\n  = MultiLineComment\n  / SingleLineComment\n\nMultiLineComment\n  = \"/*\" (!\"*/\" .)* \"*/\"\n\nSingleLineComment\n  = \"//\" (!EOL .)*\n\n// ################################################################################\n\nJSObjectRef \"JS object reference\"\n  = start:VarIdentifier tail:(( \".\" pp:Identifier) {return pp}/ ( \"[\" idx:[0-9]+ \"]\") {return parseInt(idx.join(''),10)})*\n  {var r=[start]; if (tail && tail.length) r=r.concat(tail);return {category:\"objectref\", path:r, code:r.join('.')}}\n\nJSLiteral\n  = NullLiteral       { return {type:\"expression\", category: \"null\", code:\"null\"};}\n  / v:BooleanLiteral  { return {type:\"expression\", category: \"boolean\", value:v.value, code:\"\"+v.value};}\n  / v:NumericLiteral  { return {type:\"expression\", category: \"number\", value: v, code:\"\"+v};}\n  / v:StringLiteral   { return {type:\"expression\", category: \"string\",  value: v, code:\"\"+v};}\n\n// ################################################################################\n/*!\n * The last part of this file is taken & modified from the JavaScript PEGjs grammar \n * by David Majda\n * https://github.com/dmajda/pegjs\n *\n * JavaScript parser based on the grammar described in ECMA-262, 5th ed.\n * (http://www.ecma-international.org/publications/standards/Ecma-262.htm)\n */\nSourceCharacter\n  = .\n\nIdentifier \"identifier\"\n  = !ReservedWord name:IdentifierName { return name; }\n\nIdentifierName \"identifier\"\n  = start:IdentifierStart parts:IdentifierPart* \n  {return start + parts.join(\"\");}\n\nIdentifierStart\n  = Letter // should be UnicodeLetter to be fully ECMAScript compliant - cf. PEGS JS Grammar\n  / \"$\"\n  / \"_\"\n\nVarIdentifier \"variable identifier\" // same as Identifer but without underscore as first letter\n  = !ReservedWord name:VarIdentifierName { return name; }\n\nVarIdentifierName \"identifier\"\n  = start:VarIdentifierStart parts:IdentifierPart* \n  {return start + parts.join(\"\");}\n\nVarIdentifierStart\n  = Letter // should be UnicodeLetter to be fully ECMAScript compliant - cf. PEGS JS Grammar\n  / \"$\"    // underscore is not supported as first letter\n\nIdentifierPart\n  = IdentifierStart / Digit\n\nLetter\n  = [a-zA-Z]\n\nDigit\n  = [0-9]\n\nReservedWord\n  = Keyword / FutureReservedWord / NullLiteral / BooleanLiteral\n\nKeyword\n  = (\n        \"break\"\n      / \"case\"\n      / \"catch\"\n      / \"continue\"\n      / \"debugger\"\n      / \"default\"\n      / \"delete\"\n      / \"do\"\n      / \"else\"\n      / \"finally\"\n      / \"for\"\n      / \"function\"\n      / \"if\"\n      / \"instanceof\"\n      / \"in\"\n      / \"new\"\n      / \"return\"\n      / \"switch\"\n      / \"this\"\n      / \"throw\"\n      / \"try\"\n      / \"typeof\"\n      / \"var\"\n      / \"void\"\n      / \"while\"\n      / \"with\"\n    )\n    !IdentifierPart\n\nFutureReservedWord\n  = (\n        \"class\"\n      / \"const\"\n      / \"enum\"\n      / \"export\"\n      / \"extends\"\n      / \"import\"\n      / \"super\"\n    )\n    !IdentifierPart\n\nNullLiteral\n  = \"null\" \n  {return { type: \"nullliteral\", value: null }; }\n\nBooleanLiteral\n  = \"true\"  { return { type: \"booleanliteral\", value: true  }; }\n  / \"false\" { return { type: \"booleanliteral\", value: false }; }\n\nNumericLiteral \"number\"\n  = literal:(HexIntegerLiteral / DecimalLiteral) !IdentifierStart \n  {return literal;}\n\nHexIntegerLiteral\n  = \"0\" [xX] digits:HexDigit+ \n  {return parseInt(\"0x\" + digits.join(\"\"));}\n\nHexDigit\n  = [0-9a-fA-F]\n\nDecimalLiteral\n  = before:DecimalIntegerLiteral \".\" after:DecimalDigits? exponent:ExponentPart? \n    {return parseFloat(before + \".\" + after + exponent);}\n  / \".\" after:DecimalDigits exponent:ExponentPart? \n    {return parseFloat(\".\" + after + exponent);}\n  / before:DecimalIntegerLiteral exponent:ExponentPart? \n    {return parseFloat(before + exponent);}\n\nDecimalIntegerLiteral\n  = \"0\" / digit:NonZeroDigit digits:DecimalDigits? \n  {return digit + digits;}\n\nDecimalDigits\n  = digits:DecimalDigit+ \n  {return digits.join(\"\");}\n\nDecimalDigit\n  = [0-9]\n\nNonZeroDigit\n  = [1-9]\n\nExponentPart\n  = indicator:ExponentIndicator integer:SignedInteger \n  {return indicator + integer;}\n\nExponentIndicator\n  = [eE]\n\nSignedInteger\n  = sign:[-+]? digits:DecimalDigits \n  {return sign + digits;}\n\nStringLiteral \"string\"\n  = parts:('\"' DoubleStringCharacters? '\"' / \"'\" SingleStringCharacters? \"'\") \n  {return parts[1];}\n\nDoubleStringCharacters\n  = chars:DoubleStringCharacter+ { return chars.join(\"\"); }\n\nSingleStringCharacters\n  = chars:SingleStringCharacter+ { return chars.join(\"\"); }\n\nDoubleStringCharacter\n  = !('\"' / \"\\\\\" / EOL) char_:SourceCharacter { return char_;     }\n  / \"\\\\\" sequence:EscapeSequence              { return sequence;  }\n\nSingleStringCharacter\n  = !(\"'\" / \"\\\\\" / EOL) char_:SourceCharacter { return char_;     }\n  / \"\\\\\" sequence:EscapeSequence              { return sequence;  }\n\nEscapeSequence\n  = CharacterEscapeSequence\n  / \"0\" !DecimalDigit { return \"\\0\"; }\n  / HexEscapeSequence\n  / UnicodeEscapeSequence\n\nCharacterEscapeSequence\n  = SingleEscapeCharacter\n  / NonEscapeCharacter\n\nSingleEscapeCharacter\n  = char_:['\"\\\\bfnrtv] {\n      return char_\n        .replace(\"b\", \"\\b\")\n        .replace(\"f\", \"\\f\")\n        .replace(\"n\", \"\\n\")\n        .replace(\"r\", \"\\r\")\n        .replace(\"t\", \"\\t\")\n        .replace(\"v\", \"\\x0B\") // IE does not recognize \"\\v\".\n    }\n\nNonEscapeCharacter\n  = (!EscapeCharacter / EOL) char_:SourceCharacter { return char_; }\n\nEscapeCharacter\n  = SingleEscapeCharacter\n  / DecimalDigit\n  / \"x\"\n  / \"u\"\n\nHexEscapeSequence\n  = \"x\" h1:HexDigit h2:HexDigit \n  {return String.fromCharCode(parseInt(\"0x\" + h1 + h2));}\n\nUnicodeEscapeSequence\n  = \"u\" h1:HexDigit h2:HexDigit h3:HexDigit h4:HexDigit \n  {return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));}\n\n\n/* ===== A.3 Expressions ===== */\n\nPrimaryExpression // changed \n  = name:Identifier { return { type: \"Variable\", name: name, code:name }; }\n  / JSLiteral\n  / ArrayLiteral\n  / ObjectLiteral\n  / \"(\" __ expression:Expression __ \")\" { return expression; }\n\nArrayLiteral\n  = \"[\" __ elements:ElementList? __ (Elision __)? \"]\" {\n      return {\n        type:     \"ArrayLiteral\",\n        elements: elements !== \"\" ? elements : []\n      };\n    }\n\nElementList\n  = (Elision __)?\n    head:AssignmentExpression\n    tail:(__ \",\" __ Elision? __ AssignmentExpression)* {\n      var result = [head];\n      for (var i = 0; i < tail.length; i++) {\n        result.push(tail[i][5]);\n      }\n      return result;\n    }\n\nElision\n  = \",\" (__ \",\")*\n\nObjectLiteral\n  = \"{\" __ properties:(PropertyNameAndValueList __ (\",\" __)?)? \"}\" {\n      return {\n        type:       \"ObjectLiteral\",\n        properties: properties !== \"\" ? properties[0] : []\n      };\n    }\n\nPropertyNameAndValueList\n  = head:PropertyAssignment tail:(__ \",\" __ PropertyAssignment)* {\n      var result = [head];\n      for (var i = 0; i < tail.length; i++) {\n        result.push(tail[i][3]);\n      }\n      return result;\n    }\n\nPropertyAssignment // changed\n  = name:PropertyName __ \":\" __ value:AssignmentExpression {\n      return {\n        type:  \"PropertyAssignment\",\n        name:  name,\n        value: value\n      };\n    }\n\nPropertyName\n  = IdentifierName\n  / StringLiteral\n  / NumericLiteral\n\nPropertySetParameterList\n  = Identifier\n\nMemberExpression // changed\n  = base:(\n        PrimaryExpression\n    )\n    accessors:(\n        __ \"[\" __ name:Expression __ \"]\" { return name; }\n      / __ \".\" __ name:IdentifierName    { return name; }\n    )* {\n      var result = base;\n      for (var i = 0; i < accessors.length; i++) {\n        result = {\n          type: \"PropertyAccess\",\n          base: result,\n          name: accessors[i]\n        };\n      }\n      result.code=base.code\n      if (accessors.length) {\n        var acc;\n        for (var i=0, sz=accessors.length;sz>i;i++) {\n          acc=accessors[i];\n          if (acc.code) {\n            accessors[i]=acc.code;\n          }\n        }\n        result.code+=\".\"+accessors.join(\".\");\n      }\n      return result;\n    }\n\nNewExpression // changed\n  = MemberExpression\n\nCallExpression\n  = base:(\n      name:MemberExpression __ arguments:Arguments {\n        return {\n          type:      \"FunctionCall\",\n          name:      name,\n          arguments: arguments\n        };\n      }\n    )\n    argumentsOrAccessors:(\n        __ arguments:Arguments {\n          return {\n            type:      \"FunctionCallArguments\",\n            arguments: arguments\n          };\n        }\n      / __ \"[\" __ name:Expression __ \"]\" {\n          return {\n            type: \"PropertyAccessProperty\",\n            name: name\n          };\n        }\n      / __ \".\" __ name:IdentifierName {\n          return {\n            type: \"PropertyAccessProperty\",\n            name: name\n          };\n        }\n    )* {\n      var result = base;\n      for (var i = 0; i < argumentsOrAccessors.length; i++) {\n        switch (argumentsOrAccessors[i].type) {\n          case \"FunctionCallArguments\":\n            result = {\n              type:      \"FunctionCall\",\n              name:      result,\n              arguments: argumentsOrAccessors[i].arguments\n            };\n            break;\n          case \"PropertyAccessProperty\":\n            result = {\n              type: \"PropertyAccess\",\n              base: result,\n              name: argumentsOrAccessors[i].name\n            };\n            break;\n          default:\n            throw new Error(\n              \"Invalid expression type: \" + argumentsOrAccessors[i].type\n            );\n        }\n      }\n      return result;\n    }\n\nArguments\n  = \"(\" __ arguments:ArgumentList? __ \")\" {\n    return arguments !== \"\" ? arguments : [];\n  }\n\nArgumentList\n  = head:AssignmentExpression tail:(__ \",\" __ AssignmentExpression)* {\n    var result = [head];\n    for (var i = 0; i < tail.length; i++) {\n      result.push(tail[i][3]);\n    }\n    return result;\n  }\n\nLeftHandSideExpression\n  = CallExpression\n  / NewExpression\n\nPostfixExpression\n  = expression:LeftHandSideExpression _ operator:PostfixOperator {\n      return {\n        type:       \"PostfixExpression\",\n        operator:   operator,\n        expression: expression\n      };\n    }\n  / LeftHandSideExpression\n\nPostfixOperator\n  = \"++\"\n  / \"--\"\n\nUnaryExpression\n  = PostfixExpression\n  / operator:UnaryOperator __ expression:UnaryExpression {\n      return {\n        type:       \"UnaryExpression\",\n        operator:   operator,\n        expression: expression\n      };\n    }\n\nUnaryOperator // changed\n  = \"void\"\n  / \"typeof\"\n  / \"++\"\n  / \"--\"\n  / \"+\"\n  / \"-\"\n  / \"~\"\n  /  \"!\"\n\nMultiplicativeExpression\n  = head:UnaryExpression\n    tail:(__ MultiplicativeOperator __ UnaryExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nMultiplicativeOperator\n  = operator:(\"*\" / \"/\" / \"%\") !\"=\" { return operator; }\n\nAdditiveExpression\n  = head:MultiplicativeExpression\n    tail:(__ AdditiveOperator __ MultiplicativeExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nAdditiveOperator\n  = \"+\" !(\"+\" / \"=\") { return \"+\"; }\n  / \"-\" !(\"-\" / \"=\") { return \"-\"; }\n\nShiftExpression\n  = head:AdditiveExpression\n    tail:(__ ShiftOperator __ AdditiveExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nShiftOperator\n  = \"<<\"\n  / \">>>\"\n  / \">>\"\n\nRelationalExpression\n  = head:ShiftExpression\n    tail:(__ RelationalOperator __ ShiftExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nRelationalOperator\n  = \"<=\"\n  / \">=\"\n  / \"<\"\n  / \">\"\n  / \"instanceof\"\n  / \"in\"\n\nRelationalExpressionNoIn\n  = head:ShiftExpression\n    tail:(__ RelationalOperatorNoIn __ ShiftExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nRelationalOperatorNoIn\n  = \"<=\"\n  / \">=\"\n  / \"<\"\n  / \">\"\n  / \"instanceof\"\n\nEqualityExpression\n  = head:RelationalExpression\n    tail:(__ EqualityOperator __ RelationalExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nEqualityExpressionNoIn\n  = head:RelationalExpressionNoIn\n    tail:(__ EqualityOperator __ RelationalExpressionNoIn)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nEqualityOperator\n  = \"===\"\n  / \"!==\"\n  / \"==\"\n  / \"!=\"\n\nBitwiseANDExpression\n  = head:EqualityExpression\n    tail:(__ BitwiseANDOperator __ EqualityExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nBitwiseANDExpressionNoIn\n  = head:EqualityExpressionNoIn\n    tail:(__ BitwiseANDOperator __ EqualityExpressionNoIn)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nBitwiseANDOperator\n  = \"&\" !(\"&\" / \"=\") { return \"&\"; }\n\nBitwiseXORExpression\n  = head:BitwiseANDExpression\n    tail:(__ BitwiseXOROperator __ BitwiseANDExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nBitwiseXORExpressionNoIn\n  = head:BitwiseANDExpressionNoIn\n    tail:(__ BitwiseXOROperator __ BitwiseANDExpressionNoIn)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nBitwiseXOROperator\n  = \"^\" !(\"^\" / \"=\") { return \"^\"; }\n\nBitwiseORExpression\n  = head:BitwiseXORExpression\n    tail:(__ BitwiseOROperator __ BitwiseXORExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nBitwiseORExpressionNoIn\n  = head:BitwiseXORExpressionNoIn\n    tail:(__ BitwiseOROperator __ BitwiseXORExpressionNoIn)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nBitwiseOROperator\n  = \"|\" !(\"|\" / \"=\") { return \"|\"; }\n\nLogicalANDExpression\n  = head:BitwiseORExpression\n    tail:(__ LogicalANDOperator __ BitwiseORExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nLogicalANDExpressionNoIn\n  = head:BitwiseORExpressionNoIn\n    tail:(__ LogicalANDOperator __ BitwiseORExpressionNoIn)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nLogicalANDOperator\n  = \"&&\" !\"=\" { return \"&&\"; }\n\nLogicalORExpression\n  = head:LogicalANDExpression\n    tail:(__ LogicalOROperator __ LogicalANDExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nLogicalORExpressionNoIn\n  = head:LogicalANDExpressionNoIn\n    tail:(__ LogicalOROperator __ LogicalANDExpressionNoIn)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nLogicalOROperator\n  = \"||\" !\"=\" { return \"||\"; }\n\nConditionalExpression\n  = condition:LogicalORExpression __\n    \"?\" __ trueExpression:AssignmentExpression __\n    \":\" __ falseExpression:AssignmentExpression {\n      return {\n        type:            \"ConditionalExpression\",\n        condition:       condition,\n        trueExpression:  trueExpression,\n        falseExpression: falseExpression\n      };\n    }\n  / LogicalORExpression\n\n// This is the one we use in hashspace\nConditionalExpressionNoIn\n  = condition:LogicalORExpressionNoIn __\n    \"?\" __ trueExpression:AssignmentExpressionNoIn __\n    \":\" __ falseExpression:AssignmentExpressionNoIn {\n      return {\n        type:            \"ConditionalExpression\",\n        condition:       condition,\n        trueExpression:  trueExpression,\n        falseExpression: falseExpression\n      };\n    }\n  / LogicalORExpressionNoIn\n\n// Not used in hashspace\nAssignmentExpression\n  = left:LeftHandSideExpression __\n    operator:AssignmentOperator __\n    right:AssignmentExpression {\n      return {\n        type:     \"AssignmentExpression\",\n        operator: operator,\n        left:     left,\n        right:    right\n      };\n    }\n  / ConditionalExpression\n\nAssignmentExpressionNoIn\n  = left:LeftHandSideExpression __\n    operator:AssignmentOperator __\n    right:AssignmentExpressionNoIn {\n      return {\n        type:     \"AssignmentExpression\",\n        operator: operator,\n        left:     left,\n        right:    right\n      };\n    }\n  / ConditionalExpressionNoIn\n\nAssignmentOperator\n  = \"=\" (!\"=\") { return \"=\"; }\n  / \"*=\"\n  / \"/=\"\n  / \"%=\"\n  / \"+=\"\n  / \"-=\"\n  / \"<<=\"\n  / \">>=\"\n  / \">>>=\"\n  / \"&=\"\n  / \"^=\"\n  / \"|=\"\n\nExpression\n  = head:AssignmentExpression\n    tail:(__ \",\" __ AssignmentExpression)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n\nExpressionNoIn\n  = head:AssignmentExpressionNoIn\n    tail:(__ \",\" __ AssignmentExpressionNoIn)* {\n      var result = head;\n      for (var i = 0; i < tail.length; i++) {\n        result = {\n          type:     \"BinaryExpression\",\n          operator: tail[i][1],\n          left:     result,\n          right:    tail[i][3]\n        };\n      }\n      return result;\n    }\n"}