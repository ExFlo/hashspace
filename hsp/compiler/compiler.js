var parser = require("./parser");
var klass= require("../klass");
var TreeWalker = require("./treeWalker").TreeWalker;
var processors = require("./processors");
var jsv = require("../jsvalidator/validator");

/**
 * Header added to all generated JS file
 */
var HEADER=module.exports.HEADER=[
	'// ################################################################ ',
	'//  This file has been generated by the hashspace compiler          ',
	'//  Direct MODIFICATIONS WILL BE LOST when the file is recompiled!  ',
	'// ################################################################ ',
	'',
	''
].join('\r\n');

/**
 * Compile a template and return a JS compiled string and a list of errors
 * @param template {String} the template file content as a string
 * @param fileName {String} the name of the file being compiled (optional - used for error messages)
 * @param includeSyntaxTree {Boolean} if true, the result object will contain the syntax tree generated by the compiler
 * @param bypassJSvalidation {Boolean} if true, the validation of the generated JS file 
 * 									   (including non-template code) is bypassed - default:false
 * @return {JSON} a JSON structure with the following properties:
 * 		errors: {Array} the error list - each error having the following structure:
 *				description: {String} - a message describing the error
 *				line: {Number} - the error line number
 *				column: {Number} - the error column number
 *				code: {String} - a code extract showing where the error occurs (optional)
 * 		code: {String} the generated JavaScript code
 *		syntaxTree: {JSON} the syntax tree generated by the parser (optional - cf. parameters)
 */
exports.compile = function (template, fileName, includeSyntaxTree, bypassJSvalidation) {
	// Parsing might throw an exception
	var res = parser.parse(template);
	res.code='';
	if (!fileName) {
		fileName="[anonymous]";
	}

	if (!res.errors || !res.errors.length) {
		// I'm sure res is an array otherwise the parser would have thrown an exception
		var w=new TemplateWalker();
		var out = w.walk(res.syntaxTree, processors);
	
		if (includeSyntaxTree===true) {
			res.codeFragments=w.templates;
		}

		res.code=HEADER+out.join('\r\n');
		res.errors=w.errors;
	} else {
		// Generate a JS script to show the errors when the generated file is loaded
		res.code=HEADER;
	}

	if (!res.errors) {
		res.errors=[];
	}

	if (res.errors.length==0 && bypassJSvalidation!==true) {
		// call the JS validator
		// we don't checke for JS errors when there are template errors as the code generated by the template may be wrong
		var r=jsv.validate(res.code);
		if (!r.isValid) {
			// remove all code so that script can still be loaded
			res.code=HEADER;
			Array.prototype.push.apply(res.errors,r.errors);
		}
	}

	res.code+=getErrorScript(res.errors);

	if (includeSyntaxTree!==true) {
		res.syntaxTree=null;
	}

	return res;
};

/**
 * Generate an error script to include in the template compiled script in order to show errors 
 * in the browser when the script is loaded
 */
function getErrorScript(errors) {
	var r='';
	if (errors && errors.length) {
		r=[
			'\r\nrequire("hsp/rt").logErrors(',
			JSON.stringify(errors,null),
			');\r\n'
		].join("");
	}
	return r;
}

/**
 * Walker object used to generate the template script and store some contextual information
 * such as errors or scope..
 */
var TemplateWalker=klass({
	$extends:TreeWalker,
	$constructor: function() {
		this.templates={}; // used by processors to store intermediate values in order to ease testing
		this.errors=[];
		this.resetScope();
	},

	logError:function(description, errdesc) {
		var desc={description:description};
		if (errdesc) {
			if (errdesc.line) {
				desc.line=errdesc.line;
				desc.column=errdesc.column;
			}
			if (errdesc.code) {
				desc.code=errdesc.code;
			}
		}
		this.errors.push(desc);
	},

	resetScope:function() {
		this._scopes=[{}];
		this._scope=this._scopes[0];
	},

	addScopeVariable:function(varname) {
		this._scope[varname]=true;
	},

	rmScopeVariable:function(varname) {
		this._scope[varname]=null;
	},

	isInScope:function(varname) {
		return this._scope[varname]? true : false;
	},

	pushSubScope:function(vararray) {
		var newScope=Object.create(this._scope);
		for (var i=0,sz=vararray.length;sz>i;i++) {
			newScope[vararray[i]]=true;
		}
		this._scopes.push(newScope);
		this._scope=this._scopes[this._scopes.length-1];
	},

	popSubScope:function(varnames) {
		this._scopes.pop();
		this._scope=this._scopes[this._scopes.length-1];
	}
});
